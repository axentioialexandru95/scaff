# Scanning Code for Architecture and Pattern Extraction

Building **Scaff** means statically analyzing a codebase to identify recurring structures (e.g. modules, classes, CRUD controllers, layers) and then proposing reusable templates for them.  A practical approach is to parse every source file into an Abstract Syntax Tree (AST) and run **pattern queries** on it. In Rust, a library like **Tree-sitter** (via its Rust bindings) can parse dozens of languages into precise ASTs.  Tree-sitter even provides a DSL for querying syntax patterns: “Tree-sitter queries allow you to search for patterns in syntax trees, much like a regex would in text”.  For example, one could write a query to match all REST controller classes or database model definitions.  By running such queries across the codebase, Scaff can detect instances of known architectural elements.

However, fully automatic pattern detection is inherently hard.  Research shows that *design pattern mining tools* are limited and often language-specific, and experienced developers note that “tools for detecting architecture/design patterns in code \[are] pretty complex” and unlikely to exist as turn-key solutions.  In practice, Scaff will likely combine automatic queries with user-provided hints or confirmed matches.  For example, after an initial AST scan it might list candidate components (e.g. “these files look like CRUD controllers” or “these classes form an MVC Model-View pair”) and let the user label them.  Internally, Scaff can store these findings as “code facts” or a lightweight knowledge base rather than keeping every AST in memory. By saving only the key pattern instances (names, paths, code snippets), the tool stays performant even on large projects.

One way to formalize pattern detection is to define a mini-DSL or configuration format (e.g. JSON/YAML) for “patterns” that Scaff should look for.  Each pattern could specify AST node types and relationships to match (similar to the way **pattern-supported architecture recovery** works in research). For instance, Deissenboeck *et al.* define architecture patterns (e.g. “ClientSocket”) with preconditions and code-match templates, then scan the code to find components matching those patterns.  The output was an explicit mapping of source files to architecture roles (e.g. file X implements a client, file Y a server). Scaff can adopt a similar idea: after scanning, it could cluster code into identified roles (controllers, services, repositories, etc.) by matching against pattern definitions.

* **AST Parsing:** Use Tree-sitter to generate CSTs for each language (JS/TS, Rust, Python, etc.). This handles syntax nuances and is performant for large codebases.
* **Pattern Queries:** Write reusable queries to find common structures (function groups, class hierarchies, file patterns). Queries might use Tree-sitter’s capture features (e.g. capture all functions annotated `@Controller`).
* **Design-Pattern Mining:** Optionally incorporate existing tools/libraries for known patterns (or LLM-assisted analysis), while being aware that complete automation is still an open problem.

## Saving and Managing Scaffolds (Patterns)

Once patterns are identified, Scaff allows the user to **save a “scaff”** (a snapshot of an architectural pattern or module template) in a serialized form (e.g. JSON or YAML). Each saved scaff could include metadata (name, description, language) and structural details: for example, “a CRUD resource” might record that it consists of a *Model* file, a *Controller* file, and a *Service* file with specified methods.  In Rust, crates like `serde_json` or `serde_yaml` make it easy to serialize these definitions.  By storing scaffs externally (in `scaffs/` as JSON/YAML), Scaff users build a library of architectural templates. These can be version-controlled and shared: “Architectural patterns can be reused across projects, ensuring consistency”.

Internally, Scaff might represent a scaff’s pattern as another kind of AST query or even a small abstract model.  A saved scaff could be applied later by matching its pattern in a codebase (for validation) or by using its template skeleton for generation.  For example, after scanning an existing project, Scaff could say “I detected the REST-CRUD scaff pattern here, do you want to save it for reuse?” and then allow generation of similar scaffs in new projects.

## Architecture-as-Code Validation

For checking that code follows the chosen scaff’s architecture, Scaff can perform **architecture validation** much like modern “architecture-as-code” tools.  For instance, SonarQube’s recent feature lets teams “define your architecture as code in a YAML or JSON file” and then “automatically analyze code structure… raising issues on any divergence”.  Similarly, Scaff can use predefined rules to verify that new or existing code adheres to the expected layout.  This might involve simple checks (e.g. ensure controllers only call services, not the database layer directly) or more complex ones (e.g. certain modules cannot depend on each other).  By integrating these rules into the CLI (as a `validate` command), developers get immediate feedback if they stray from the intended scaff pattern.

&#x20;*Figure: Example “architecture-as-code” model, mapping logical layers (UI, Server, Storage) to actual package globs (e.g. `com.acme.ui.*`) and visualizing class dependencies.  Tools like SonarQube allow defining such models in YAML and automatically checking the code against them. Scaff can adopt a similar layered-architecture approach for validation.*

## Generating Code from Scaffolds

The other half of Scaff is code generation. Once a pattern is defined and saved, Scaff should be able to “scaffold” new code that fits that pattern. In practice this means writing code templates (with placeholders) and using a templating engine to fill them. The plan to use a crate like Handlebars or Mustache is sound: these allow easy embedding of variable names and conditionals in code templates.  For example, a “CRUD resource” scaff could include a template for a `ResourceController`, a `ResourceService`, and a `ResourceRepository`, with loops to generate methods for each field.

There are existing Rust tools that illustrate this approach. For instance, **skeletor** is a Rust CLI scaffolder driven by YAML “snapshots”, and **kickstart** uses the Tera templating engine for project boilerplate. These tools demonstrate that storing code-generation patterns in external templates (and then rendering them) is effective. Scaff can incorporate a similar system: e.g., keep `templates/` of Handlebars files for common patterns, and let the user run `scaff generate <scaff-name>` to produce code. The CLI (built with `clap`) can prompt for any required parameters.

For maximal flexibility, Scaff’s generator could support conditional logic (include certain files only if needed) and pre/post hooks (e.g. `git init` a new repo).  Over time, a community could contribute many scaff templates.  The result: instead of hand-coding every layer, a developer types `scaff gen crud Users` and gets a ready-made UsersController, UsersService, etc., consistent with their saved architecture.

## Implementation Roadmap

To implement Scaff in Rust step-by-step:

1. **CLI Setup:** Use `clap` to define commands like `scan`, `save`, `list`, `generate`, and `validate`. Ensure modular code (e.g. separate modules for scanning, generation, validation).
2. **Integrate Tree-sitter:** Add crates for tree-sitter and language grammars (starting with JS/TS, then Rust, Python, etc.). Implement `scan` to load project files into parsers and run queries. Use Tree-sitter’s query DSL to detect patterns.
3. **Pattern Extraction:** Design a representation (in `pattern.rs`) for extracted patterns. For example, pattern matches could include captured identifiers or structure shapes. Serialize these via `serde_json` into the `scaffs/` directory.
4. **Template System:** Create sample templates in `templates/`. Integrate a templating crate (e.g. `handlebars`) so `generate` can load a template, fill in names and parameters, and write files.
5. **Validation Engine:** Build `validator.rs` that takes a selected scaff (or architecture model) and checks the current code. This might reuse Tree-sitter queries or simple file/namespace checks. Optionally support an “architecture YAML” format like Sonar’s (groups and constraints) to define allowed dependencies.
6. **Extensibility:** Abstract language-specific details into plugins (e.g. a `plugins` module). Users or the community could write plugins to add new pattern queries or generators for niche frameworks.

By combining precise static analysis with user-defined templates, Scaff can “take your architecture with you” into new projects. Developers get consistent boilerplate and architecture checks automatically, reducing errors and onboarding time. As one advertisement for architecture-as-code concludes, keeping design intent in code (and in sync with implementation) ensures “what you intend to build is what you actually deploy”. Ultimately, Scaff aims to bring that vision to everyday development: scan an existing codebase for its patterns, save them as reusable scaffolds, and then auto-generate the corresponding structure in future projects – making *architecture in your pocket* a reality.

**Key Techniques and Tools:** tree-sitter for parsing and queries; serde for scaff (JSON/YAML) storage; Handlebars/Mustache/Tera for code templates; and modern “architecture-as-code” practices for validation (as exemplified by SonarQube or FINOS CALM). Existing Rust scaffolding crates (e.g. *skeletor*, *kickstart*) show this approach is practical.  Carefully combining these techniques will allow Scaff to discover code patterns and generate robust, testable components in a repeatable way – exactly the streamlined workflow the question envisions.

**References:** Research on design-pattern extraction and developer discussions underline the challenges of pattern mining. Tree-sitter documentation and blogs show how to query ASTs. Sonar’s Architecture-as-Code blog illustrates pattern-based architecture validation.  Rust ecosystem resources list scaffolding tools that inspire the generator component. These inform a comprehensive implementation plan.
